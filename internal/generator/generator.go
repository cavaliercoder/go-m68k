/*
Package generator provides code generation for all Motorola 68000 operation
codes.

This package is used by m68kgen to generate opcodes.go in the m68k processor
package.
*/
package generator

import (
	"bytes"
	"crypto/md5"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"strings"
)

const (
	SizeByte = iota
	SizeWord
	SizeLong
)

// See table 3-19
const (
	CondTrue = iota
	CondFalse
	CondHigh
	CondLowOrSame
	CondCarryClear
	CondCarrySet
	CondNotEqual
	CondEqual
	CondOverflowClean
	CondOverflowSet
	CondPlus
	CondMinus
	CondGreaterOrEqual
	CondLessThan
	CondGreaterThan
	CondLessOrEqual
)

// See section 1.1.4
const (
	StatusCarry    = 1 << iota // C
	StatusOverflow             // V
	StatusZero                 // Z
	StatusNegative             // N
	StatusExtend               // X
)

type EffectiveAddressMask int

// See table 2-4
const (
	EADataRegister = EffectiveAddressMask(1) << iota
	EAAddressRegister
	EAAddressRegisterIndirect
	EAAddressRegisterIndirectPostInc
	EAAddressRegisterIndirectPreDec
	EAAddressRegisterIndirectDisplace
	EAAddressRegisterIndex
	EAProgramCounterIndirectDisplace
	EAProgramCounterIndex
	EAAbsoluteShort
	EAAbsoluteLong
	EAImmediate

	EAControlModes = EAAddressRegisterIndex |
		EAAddressRegisterIndirectDisplace |
		EAAddressRegisterIndex |
		EAAbsoluteLong |
		EAAbsoluteShort |
		EAProgramCounterIndirectDisplace |
		EAProgramCounterIndex
)

var RegisterMasks = []uint32{
	0xFFFFFF00, // byte
	0xFFFF0000, // word
	0x00,       // long
}

var SizeTypes = []string{
	"byte",   // byte
	"uint16", // word
	"uint32", // long
}

var SizeLengths = []int{
	1, // SizeByte
	2, // SizeWord
	4, // SizeLong
}

var (
	errNotImplemented = errors.New("not implemented")
	errInvalidOpSize  = errors.New("invalid operand size")
	errInvalidAddress = errors.New("invalid effect address")
)

type genFunc func(*IndentWriter, uint16) error

type opFunc struct {
	Name, Body string
}

func (f *opFunc) Hash() string {
	h := md5.New()
	r := strings.NewReader(f.Body)
	io.Copy(h, r)
	return hex.EncodeToString(h.Sum(nil))
}

// Generate writes Go code to the given Writer which implements all supported
// 68000 operation codes.
func Generate(w io.Writer) (err error) {
	printFileHdr(w)

	uniq := make(map[string]*opFunc, 0)
	fmap := make([]string, 0x10000)

	b := &bytes.Buffer{}
	fw := NewIndentWriter(b, "\t", 0)
	for op := uint16(0x0000); op < 0xFFFF; op++ {
		b.Reset()
		fw.Reset()

		// write function header
		fn := &opFunc{
			Name: fmt.Sprintf("op%04X", op),
		}
		fmt.Fprintf(fw, "func (c *Processor) op%04X() {\n", op)
		fw.Increment(1)

		// dispatch to generate function body
		err = dispatch(fw, op)
		if err == errNotImplemented {
			err = nil
			continue
		} else if err != nil {
			return
		}

		// write function footer
		fw.Decrement(1)
		fmt.Fprint(fw, "}\n\n")

		// search for existing implementation
		fn.Body = b.String()
		h := fn.Hash()
		if v, ok := uniq[h]; ok {
			fn.Name = v.Name
		} else {
			uniq[h] = fn
		}
		fmap[op] = fn.Name
	}

	for _, fn := range uniq {
		w.Write([]byte(fn.Body))
	}

	fmt.Fprintf(w, "func (c *Processor) mapFn(op uint16) func() {\n")
	// fmt.Fprintf(w, "	table := map[uint16]func(){\n")
	fmt.Fprintf(w, "	return []func(){\n")
	for i := 0; i < len(fmap); i++ {
		if fmap[i] != "" {
			fmt.Fprintf(w, "		c.%s,\n", fmap[i])
		} else {
			fmt.Fprintf(w, "		nil,\n")
		}
	}
	fmt.Fprintf(w, "	}[op]\n")
	fmt.Fprintf(w, "}\n")
	return
}

func dispatch(w *IndentWriter, op uint16) (err error) {
	funcs := []genFunc{
		genTrap, gen06,
	}
	for _, fn := range funcs {
		err = fn(w, op)
		if err == errNotImplemented {
			continue
		}
		if err == nil {
			return
		}
		// TODO: handle error
		// fmt.Fprintf(os.Stderr, "Opcode %04X: %v\n", op, err)
	}
	err = errNotImplemented
	return
}

func allowEffectiveAddress(ea byte, mask EffectiveAddressMask) bool {
	mod := ea & 0x38 >> 3
	reg := ea & 0x07
	switch mod {
	default:
		return false
	case 0x00:
		return mask&EADataRegister != 0
	case 0x01:
		return mask&EAAddressRegister != 0
	case 0x02:
		return mask&EAAddressRegisterIndirect != 0
	case 0x03:
		return mask&EAAddressRegisterIndirectPostInc != 0
	case 0x04:
		return mask&EAAddressRegisterIndirectPreDec != 0
	case 0x05:
		return mask&EAAddressRegisterIndirectDisplace != 0
	case 0x06:
		return mask&EAAddressRegisterIndex != 0
	case 0x07:
		switch reg {
		default:
			return false
		case 0x00:
			return mask&EAAbsoluteShort != 0
		case 0x01:
			return mask&EAAbsoluteLong != 0
		case 0x02:
			return mask&EAProgramCounterIndirectDisplace != 0
		case 0x03:
			return mask&EAProgramCounterIndex != 0
		case 0x04:
			return mask&EAImmediate != 0
		}
	}
}

func printFileHdr(w io.Writer) {
	hdr := `package m68k

/**
 * This file is generated by m68kgen
 * Hand written changes will be overwritten!
 */

`
	fmt.Fprintf(w, hdr)
}

func printOpFuncHdr(w io.Writer, op uint16) {
	fmt.Fprintln(w, "pc := c.PC")
	fmt.Fprintln(w, "c.PC += 2")
}

func printOpFuncFtr(w io.Writer, t *traceMessage) {
	fmt.Fprintf(w, "%s\n", t)
}

type traceMessage struct {
	op, src, dst string
	sz           uint16
	args         []string

	noSize bool
}

func (t *traceMessage) String() string {
	args := &bytes.Buffer{}
	for i := 0; i < len(t.args); i++ {
		fmt.Fprintf(args, ", %s", t.args[i])
	}
	operands := t.dst
	if t.dst == "" {
		operands = t.src
	} else if t.src != "" {
		operands = fmt.Sprintf("%s,%s", t.src, t.dst)
	}
	if t.noSize {
		return fmt.Sprintf("c.tracef(\"%%04X %s %s\\n\", pc%s)", t.op, operands, args)
	}
	sz := []string{"b", "w", "l"}[t.sz]
	return fmt.Sprintf("c.tracef(\"%%04X %s.%s %s\\n\", pc%s)", t.op, sz, operands, args)
}

func printReadMem(w io.Writer, name, addr string, sz uint16) {
	n := []int{1, 2, 4}[sz]
	fmt.Fprintf(w, "_, c.err = c.M.Read(int(%s), c.buf[:%d])\n", addr, n)
	fmt.Fprintln(w, "if c.err != nil {")
	fmt.Fprintln(w, "	return")
	fmt.Fprintln(w, "}")
	switch sz {
	case 0:
		fmt.Fprintln(w, name, ":= c.buf[0]")
	case 1:
		fmt.Fprintln(w, name, ":= uint16(c.buf[0])<<8 | uint16(c.buf[1])")
	case 2:
		fmt.Fprintln(w, name, ":= uint32(c.buf[3]) | uint32(c.buf[2])<<8 | uint32(c.buf[1])<<16 | uint32(c.buf[0])<<24")
	}
}

func printReadImm(w io.Writer, name string, sz uint16) {
	n := []int{2, 2, 4}[sz] // single bytes are 16bit aligned
	fmt.Fprintf(w, "_, c.err = c.M.Read(int(c.PC), c.buf[:%d])\n", n)
	fmt.Fprintln(w, "if c.err != nil {")
	fmt.Fprintln(w, "	return")
	fmt.Fprintln(w, "}")
	fmt.Fprintf(w, "c.PC += %d\n", n)
	switch sz {
	case SizeByte:
		fmt.Fprintln(w, name, ":= c.buf[1]")
	case SizeWord:
		fmt.Fprintln(w, name, ":= uint16(c.buf[0])<<8 | uint16(c.buf[1])")
	case SizeLong:
		fmt.Fprintln(w, name, ":= uint32(c.buf[0])<<24 | uint32(c.buf[1])<<16 | uint32(c.buf[2])<<8 | uint32(c.buf[3])")
	}
}

func printWriteMem(w io.Writer, name, addr string, sz uint16) {

	n := []int{1, 2, 4}[sz]
	switch sz {
	case 0: // byte
		fmt.Fprintf(w, "c.buf[0] = byte(%s)\n", name)

	case 1: // word
		fmt.Fprintf(w, "c.buf[0] = byte(%s >> 8)\n", name)
		fmt.Fprintf(w, "c.buf[1] = byte(%s)\n", name)

	case 2: // long
		fmt.Fprintf(w, "c.buf[0] = byte(%s >> 24)\n", name)
		fmt.Fprintf(w, "c.buf[1] = byte(%s >> 16)\n", name)
		fmt.Fprintf(w, "c.buf[2] = byte(%s >> 8)\n", name)
		fmt.Fprintf(w, "c.buf[3] = byte(%s)\n", name)
	}
	fmt.Fprintf(w, "_, c.err = c.M.Write(int(%s), c.buf[:%d])\n", addr, n)
	fmt.Fprintln(w, "if c.err != nil {")
	fmt.Fprintln(w, "	return")
	fmt.Fprintln(w, "}")
}

func printSourceRead(w io.Writer, name string, ea byte, sz uint16, t *traceMessage) (err error) {
	mod := ea & 0x38 >> 3
	reg := ea & 0x07

	switch mod {
	default:
		return errInvalidAddress

	case 0x00: // data register
		fmt.Fprintf(w, "%s := c.D[%d]\n", name, reg)
		t.src = fmt.Sprintf("D%d", reg)

	case 0x01: // address register
		fmt.Fprintf(w, "%s := c.A[%d]\n", name, reg)
		t.src = fmt.Sprintf("A%d", reg)

	case 0x02: // memory address
		printReadMem(w, name, fmt.Sprintf("c.A[%d]", reg), sz)
		t.src = fmt.Sprintf("(A%d)", reg)

	case 0x03: // address indirect with post-increment
		printReadMem(w, name, fmt.Sprintf("c.A[%d]", reg), sz)
		inc := SizeLengths[sz]
		if reg == 0x07 && sz == 0 {
			// align stack pointer to 16-bit boundary (see: 2.2.4)
			inc = 2
		}
		fmt.Fprintf(w, "c.A[%d] += %d\n", reg, inc)
		t.src = fmt.Sprintf("(A%d)+", reg)

	case 0x04: // address indirect with pre-decrement
		inc := SizeLengths[sz]
		if reg == 0x07 && sz == 0 {
			// align stack pointer to 16-bit boundary (see: 2.2.4)
			inc = 2
		}
		fmt.Fprintf(w, "c.A[%d] -= %d\n", reg, inc)
		printReadMem(w, name, fmt.Sprintf("c.A[%d]", reg), sz)
		t.src = fmt.Sprintf("-(A%d)", reg)

	case 0x07:
		switch reg {
		default:
			return errInvalidAddress

		case 0x00, 0x01: // absolute short/long
			printReadImm(w, name, sz)
			t.src = "$%X"
			t.args = append(t.args, name)

		case 0x02: // program counter with displacement
			printReadImm(w, "d", SizeWord)
			fmt.Fprintf(w, "%s := c.PC + uint32(d) - 2\n", name) // -2 because readImm bumped the PC
			t.src = "$%X(PC)"
			t.args = append(t.args, "d")

		case 0x04: // immediate
			printReadImm(w, name, sz)
			t.src = "#$%X"
			t.args = append(t.args, name)
		}
	}
	return
}

func printDestRead(w io.Writer, name string, ea byte, sz uint16, t *traceMessage) (err error) {
	mod := ea & 0x38 >> 3
	reg := ea & 0x07

	switch mod {
	default:
		return errInvalidAddress

	case 0x00: // data register
		fmt.Fprintf(w, "%s := c.D[%d]\n", name, reg)
		t.dst = fmt.Sprintf("D%d", reg)

	case 0x01: // address register
		fmt.Fprintf(w, "%s := c.A[%d]\n", name, reg)
		t.dst = fmt.Sprintf("A%d", reg)

	case 0x02: // memory address
		printReadMem(w, name, fmt.Sprintf("c.A[%d]", reg), sz)
		t.dst = fmt.Sprintf("(A%d)", reg)

	case 0x07:
		switch reg {
		default:
			return errInvalidAddress

		case 0x00, 0x01: // absolute short/long
			printReadImm(w, name, sz)
			t.dst = "$%X"
			t.args = append(t.args, name)

		case 0x04: // immediate
			printReadImm(w, name, sz)
			t.dst = "#$%X"
			t.args = append(t.args, name)
		}
	}
	return
}

func printDestWrite(w io.Writer, ea byte, t *traceMessage) (err error) {
	mod := ea & 0x38 >> 3
	reg := ea & 0x07
	switch mod {
	default:
		return errInvalidAddress

	case 0x00: // data register
		// TODO: sign extension
		fmt.Fprintf(w, "c.D[%d] = uint32(v)\n", reg)
		t.dst = fmt.Sprintf("D%d", reg)

	case 0x01: // address register
		fmt.Fprintf(w, "c.A[%d] = uint32(v)\n", reg)
		t.dst = fmt.Sprintf("A%d", reg)
		t.op = "movea"

	case 0x02: // memory address
		printWriteMem(w, "v", fmt.Sprintf("c.A[%d]", reg), SizeLong)
		t.dst = fmt.Sprintf("(A%d)", reg)

	case 0x03: // memory address with post-increment
		printWriteMem(w, "v", fmt.Sprintf("c.A[%d]", reg), SizeLong)
		fmt.Fprintf(w, "c.A[%d] += 4\n", reg)
		t.dst = fmt.Sprintf("(A%d)+", reg)

	case 0x04: // memory address with pre-decrement
		fmt.Fprintf(w, "c.A[%d] -= 4\n", reg)
		printWriteMem(w, "v", fmt.Sprintf("c.A[%d]", reg), SizeLong)
		t.dst = fmt.Sprintf("-(A%d)", reg)

	case 0x05: // memory address with displacement
		printReadImm(w, "disp", SizeWord)
		fmt.Fprintf(w, "addr := uint32(disp) + c.A[%d]\n", reg)
		printWriteMem(w, "v", "addr", SizeLong)
		t.dst = fmt.Sprintf("(%%d,A%d)", reg)
		t.args = append(t.args, "disp")

	case 0x07: // other
		switch reg {
		default:
			return errInvalidAddress

		case 0x00: // absolute word
			printReadImm(w, "addr", SizeWord)
			printWriteMem(w, "v", "uint32(addr)", SizeLong)
			t.dst = "$%X"
			t.args = append(t.args, "addr")

		case 0x01: // absolute long
			printReadImm(w, "addr", SizeLong)
			printWriteMem(w, "v", "addr", SizeLong)
			t.dst = "$%X"
			t.args = append(t.args, "addr")
		}
	}
	return
}

// genTrap implements the following operations:
// - TRAP						4-118
//
func genTrap(w *IndentWriter, op uint16) (err error) {
	if op&0xFFF0 != 0x4E40 {
		err = errNotImplemented
		return
	}
	vec := (op & 0x00F)
	t := &traceMessage{
		op:     "trap",
		src:    fmt.Sprintf("#%d", vec),
		noSize: true,
	}
	vec += 32

	printOpFuncHdr(w, op)

	// TODO: traps should do something
	fmt.Fprintf(w, "if c.handlers[%d] != nil {\n", vec)
	w.Increment(1)
	fmt.Fprintf(w, "c.err = c.handlers[%d].Exception(c, %d)\n", vec, vec)
	w.Decrement(1)
	fmt.Fprintln(w, "}")

	printOpFuncFtr(w, t)
	return
}

// gen06 implements operations starting in 0110
func gen06(w *IndentWriter, op uint16) (err error) {
	err = errNotImplemented
	if op&0xF000 != 0x6000 {
		return
	}
	cnd := op & 0x0F00
	if cnd == 0x01 { // BSR
		return
	}
	err = genBcc(w, op)
	return
}

// genBcc implements:
// - Bcc (4-25)
// - BRA (4-55)
func genBcc(w *IndentWriter, op uint16) (err error) {
	cc := op & 0x0F00 >> 8
	ops := []string{
		"bra", // bra
		"bsr", // bsr (this should never happen)
		"bhi", // high
		"bls", // low or same
		"bcc", // (hi) carry clear
		"bcs", // (lo) carry set
		"bne", // not equal
		"beq", // equal
		"bvc", // overflow clear
		"bvs", // overflow set
		"bpl", // plus
		"bmi", // minus
		"bge", // greater or equal
		"blt", // less than
		"bgt", // greater than
		"ble", // less or equal
	}[cc]

	// TODO: implement other conditions
	switch cc {
	case 0x00:
	case 0x07:
		// continue

	default:
		err = errNotImplemented
		return
	}

	d := op & 0x000F
	t := &traceMessage{
		op:     ops,
		noSize: true,
		dst:    "$%d(PC)",
		args:   []string{"int32(d)"},
	}

	printOpFuncHdr(w, op)

	switch cc {
	default:
		// TODO: implement other conditions
		err = errNotImplemented
		return

	case CondTrue:
		// branch always
		fmt.Fprintln(w, "branch := true")

	case CondEqual:
		// branch if equal
		fmt.Fprintf(w, "branch := c.SR&0x%X != 0\n", StatusZero)
	}

	if d == 0 {
		// 16-bit displacement
		printReadImm(w, "d", SizeWord)
	} else if d == 0x0F {
		// 32-bit displacement
		printReadImm(w, "d", SizeLong)
	} else {
		// 8-bit displacement
		fmt.Fprintln(w, "d := byteToInt32(byte(c.op))")
	}

	// TODO: implement conditions
	fmt.Fprintln(w, "if branch {")
	fmt.Fprintln(w, "	c.PC = uint32(int32(c.PC) + int32(d))")
	fmt.Fprintln(w, "}")
	printOpFuncFtr(w, t)
	return
}
