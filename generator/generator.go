/*
Package generator provides code generation for all Motorola 68000 operation
codes.

This package is used by m68kgen to generate opcodes.go in the m68k processor
package.
*/
package generator

import (
	"bytes"
	"errors"
	"fmt"
	"io"
)

const (
	SizeByte = iota
	SizeWord
	SizeLong
)

var RegisterMasks = []uint32{
	0xFFFFFF00, // byte
	0xFFFF0000, // word
	0x00,       // long
}

var SizeTypes = []string{
	"byte",   // byte
	"uint16", // word
	"uint32", // long
}

var (
	errNotImplemented = errors.New("not implemented")
	errInvalidOpSize  = errors.New("invalid operand size")
	errInvalidAddress = errors.New("invalid effect address")
)

type genFunc func(uint16) (string, error)

// Generate writes Go code to the given Writer which implements all supported
// 68000 operation codes.
func Generate(w io.Writer) error {
	printFileHdr(w)

	opcodes := make([]bool, 0x10000)
	for op := uint16(0x0000); op < 0xFFFF; op++ {
		fn, err := dispatch(op)
		if err == nil {
			w.Write([]byte(fn))
			// opcodes[ = append(opcodes, op)]
			opcodes[op] = true
		}
	}

	fmt.Fprintf(w, "func (c *Processor) mapFn(op uint16) func() {\n")
	// fmt.Fprintf(w, "	table := map[uint16]func(){\n")
	fmt.Fprintf(w, "	return []func(){\n")
	for i := 0; i < len(opcodes); i++ {
		if opcodes[i] {
			fmt.Fprintf(w, "		c.op%04X,\n", i)
		} else {
			fmt.Fprintf(w, "		nil,\n")
		}
		// fmt.Fprintf(w, "		0x%04X: c.op%04X,\n", opcodes[i], opcodes[i])
	}
	fmt.Fprintf(w, "	}[op]\n")
	fmt.Fprintf(w, "}\n")
	return nil
}

func dispatch(op uint16) (s string, err error) {
	funcs := []genFunc{
		genORI, genMove, genTrap,
	}
	for _, fn := range funcs {
		s, err = fn(op)
		if err == errNotImplemented {
			continue
		}
		if err == nil {
			return
		}
		// TODO: handle error
		// fmt.Fprintf(os.Stderr, "Opcode %04X: %v\n", op, err)
	}
	err = errNotImplemented
	return
}

func bufWriter() *IndentWriter {
	return NewIndentWriter(&bytes.Buffer{}, "\t", 0)
}

func printFileHdr(w io.Writer) {
	hdr := `package m68k

/**
 * This file is generated by m68kgen
 * Hand written changes will be overwritten!
 */

`
	fmt.Fprintf(w, hdr)
}

func printOpFuncHdr(w io.Writer, op uint16) {
	fmt.Fprintf(w, "func (c *Processor) op%04X() {\n", op)
	fmt.Fprintln(w, "	pc := c.PC")
	fmt.Fprintln(w, "	c.PC += 2")
}

func printOpFuncFtr(w io.Writer, t *traceMessage) {
	fmt.Fprintf(w, "	%s\n", t)
	fmt.Fprint(w, "}\n\n")
}

type traceMessage struct {
	op, src, dst string
	sz           uint16
	args         []string

	noSize bool
}

func (t *traceMessage) String() string {
	args := &bytes.Buffer{}
	for i := 0; i < len(t.args); i++ {
		fmt.Fprintf(args, ", %s", t.args[i])
	}
	operands := t.dst
	if t.dst == "" {
		operands = t.src
	} else if t.src != "" {
		operands = fmt.Sprintf("%s,%s", t.src, t.dst)
	}
	if t.noSize {
		return fmt.Sprintf("c.tracef(\"%%04X %s %s\\n\", pc%s)", t.op, operands, args)
	}
	sz := []string{"b", "w", "l"}[t.sz]
	return fmt.Sprintf("c.tracef(\"%%04X %s.%s %s\\n\", pc%s)", t.op, sz, operands, args)
}

func printReadMem(w io.Writer, name, addr string, sz uint16) {
	n := []int{1, 2, 4}[sz]
	fmt.Fprintf(w, "_, c.err = c.M.Read(int(%s), c.buf[:%d])\n", addr, n)
	fmt.Fprintln(w, "if c.err != nil {")
	fmt.Fprintln(w, "	return")
	fmt.Fprintln(w, "}")
	switch sz {
	case 0:
		fmt.Fprintln(w, name, ":= c.buf[0]")
	case 1:
		fmt.Fprintln(w, name, ":= uint16(c.buf[0])<<8 | uint16(c.buf[1])")
	case 2:
		fmt.Fprintln(w, name, ":= uint32(c.buf[3]) | uint32(c.buf[2])<<8 | uint32(c.buf[1])<<16 | uint32(c.buf[0])<<24")
	}
}

func printReadImm(w io.Writer, name string, sz uint16) {
	n := []int{2, 2, 4}[sz] // single bytes are 16bit aligned
	fmt.Fprintf(w, "_, c.err = c.M.Read(int(c.PC), c.buf[:%d])\n", n)
	fmt.Fprintln(w, "if c.err != nil {")
	fmt.Fprintln(w, "	return")
	fmt.Fprintln(w, "}")
	fmt.Fprintf(w, "c.PC += %d\n", n)
	switch sz {
	case 0: // byte
		fmt.Fprintln(w, name, ":= c.buf[1]")
	case 1: // word
		fmt.Fprintln(w, name, ":= uint16(c.buf[0])<<8 | uint16(c.buf[1])")
	case 2: // long
		fmt.Fprintln(w, name, ":= uint32(c.buf[0])<<24 | uint32(c.buf[1])<<16 | uint32(c.buf[2])<<8 | uint32(c.buf[3])")
	}
}

// func printWriteMem(w io.Writer, addr string, sz uint16) {
// 	n := []int{1, 2, 4}[sz]
// 	switch sz {
// 	case 0: // byte
// 		fmt.Println(w, "c.buf[0] = byte(v)")

// 	case 1: // word
// 		fmt.Println(w, "c.buf[0] = byte(v >> 8)")
// 		fmt.Println(w, "c.buf[1] = byte(v)")

// 	case 2: // long
// 		fmt.Println(w, "c.buf[0] = byte(v >> 24)")
// 		fmt.Println(w, "c.buf[1] = byte(v >> 16)")
// 		fmt.Println(w, "c.buf[2] = byte(v >> 8)")
// 		fmt.Println(w, "c.buf[3] = byte(v)")
// 	}
// 	fmt.Fprintf(w, "_, c.err = c.M.Write(int(%s), c.buf[:%d]\n", addr, n)
// 	fmt.Fprintln(w, "if c.err != nil {")
// 	fmt.Fprintln(w, "	return")
// 	fmt.Fprintln(w, "}")
// }

func printSourceRead(w io.Writer, name string, ea byte, sz uint16, t *traceMessage) (err error) {
	mod := ea & 0x38 >> 3
	reg := ea & 0x07

	switch mod {
	default:
		return errInvalidAddress

	case 0x00: // data register
		fmt.Fprintf(w, "%s := c.D[%d]\n", name, reg)
		t.src = fmt.Sprintf("D%d", reg)

	case 0x01: // address register
		fmt.Fprintf(w, "%s := c.A[%d]\n", name, reg)
		t.src = fmt.Sprintf("A%d", reg)

	case 0x02: // memory address
		printReadMem(w, name, fmt.Sprintf("c.A[%d]", reg), sz)
		t.src = fmt.Sprintf("(A%d)", reg)

	case 0x07:
		switch reg {
		default:
			return errInvalidAddress

		case 0x00, 0x01: // absolute short/long
			printReadImm(w, name, sz)
			t.src = "$%X"
			t.args = append(t.args, name)

		case 0x04: // immediate
			printReadImm(w, name, sz)
			t.src = "#$%X"
			t.args = append(t.args, name)
		}
	}
	return
}

func printDestRead(w io.Writer, name string, ea byte, sz uint16, t *traceMessage) (err error) {
	mod := ea & 0x38 >> 3
	reg := ea & 0x07

	switch mod {
	default:
		return errInvalidAddress

	case 0x00: // data register
		fmt.Fprintf(w, "%s := c.D[%d]\n", name, reg)
		t.dst = fmt.Sprintf("D%d", reg)

	case 0x01: // address register
		fmt.Fprintf(w, "%s := c.A[%d]\n", name, reg)
		t.dst = fmt.Sprintf("A%d", reg)

	case 0x02: // memory address
		printReadMem(w, name, fmt.Sprintf("c.A[%d]", reg), sz)
		t.dst = fmt.Sprintf("(A%d)", reg)

	case 0x07:
		switch reg {
		default:
			return errInvalidAddress

		case 0x00, 0x01: // absolute short/long
			printReadImm(w, name, sz)
			t.dst = "$%X"
			t.args = append(t.args, name)

		case 0x04: // immediate
			printReadImm(w, name, sz)
			t.dst = "#$%X"
			t.args = append(t.args, name)
		}
	}
	return
}

func printDestWrite(w io.Writer, ea byte, t *traceMessage) (err error) {
	mod := ea & 0x38 >> 3
	reg := ea & 0x07
	switch mod {
	default:
		return errInvalidAddress

	case 0x00: // data register
		// TODO: sign extension
		fmt.Fprintf(w, "c.D[%d] = uint32(v)\n", reg)
		t.dst = fmt.Sprintf("D%d", reg)

	case 0x01: // address register
		fmt.Fprintf(w, "c.A[%d] = uint32(v)\n", reg)
		t.dst = fmt.Sprintf("A%d", reg)
		t.op = "movea"

	case 0x02: // memory address
		fmt.Fprintf(w, "c.writeLong(c.A[%d], uint32(v))\n", reg)
		t.dst = fmt.Sprintf("(A%d)", reg)

	case 0x03: // memory address with post-increment
		fmt.Fprintf(w, "c.writeLong(c.A[%d], uint32(v))\n", reg)
		fmt.Fprintf(w, "c.A[%d] += 4\n", reg)
		t.dst = fmt.Sprintf("(A%d)+", reg)

	case 0x04: // memory address with pre-decrement
		fmt.Fprintf(w, "c.A[%d] -= 4\n", reg)
		fmt.Fprintf(w, "c.writeLong(c.A[%d], uint32(v))\n", reg)
		t.dst = fmt.Sprintf("-(A%d)", reg)

	case 0x05: // memory address with displacement
		printReadImm(w, "disp", SizeWord)
		fmt.Fprintf(w, "addr := uint32(disp) + c.A[%d]\n", reg)
		fmt.Fprint(w, "c.writeLong(addr, uint32(v))\n")
		t.dst = fmt.Sprintf("(%%d,A%d)", reg)
		t.args = append(t.args, "disp")

	case 0x07: // other
		switch reg {
		default:
			return errInvalidAddress

		case 0x00: // absolute word
			printReadImm(w, "addr", SizeWord)
			fmt.Fprint(w, "c.writeLong(uint32(addr), uint32(v))\n")
			t.dst = "$%X"
			t.args = append(t.args, "addr")

		case 0x01: // absolute long
			printReadImm(w, "addr", SizeLong)
			fmt.Fprint(w, "c.writeLong(addr, uint32(v))\n")
			t.dst = "$%X"
			t.args = append(t.args, "addr")
		}
	}
	return
}

func genMove(op uint16) (fn string, err error) {
	if op&0xC000 != 0 {
		err = errNotImplemented
		return
	}
	src := byte(op & 0x003F)
	dst := byte((op&0x01C0)>>3 | (op&0x0E00)>>9)

	// Decode operand size
	// Move employs an usual encoding of the operand size field. The last step
	// here normalizes this unusual size value to the same encoding used by other
	// instructions.
	sz := (op & 0x3000) >> 12
	if sz == 0 {
		err = errInvalidOpSize
		return
	}
	sz = []uint16{0, 0, 2, 1}[sz]

	t := &traceMessage{
		op: "move",
		sz: sz,
	}
	if src&0x38 == 0x08 && dst&0x20 == 0x20 {
		t.op = "movep"
	}
	if dst&0x38 == 0x08 {
		t.op = "movea"
	}
	w := bufWriter()
	printOpFuncHdr(w, op)
	w.Increment(1)
	if err = printSourceRead(w, "v", src, sz, t); err != nil {
		return
	}
	if err = printDestWrite(w, dst, t); err != nil {
		return
	}
	w.Decrement(1)
	printOpFuncFtr(w, t)
	return w.String(), nil
}

// genORI implements the following operations:
// - ORI to SR		4-155
// - ORI to SR		6-27
// - ORI					4-153
// - ANDI to SR	4-20
// - ANDI to SR		6-2
// - ANDI					4-18
// - SUBI
// - ADDI
func genORI(op uint16) (fn string, err error) {
	if op&0xF000 != 0 {
		err = errNotImplemented
		return
	}
	mod := (op & 0x38) >> 3
	reg := op & 0x07
	sz := (op & 0xC0) >> 6
	if sz == 0x03 {
		err = errNotImplemented
		return
	}
	t := &traceMessage{
		op:   "?",
		sz:   sz,
		src:  "#$%X",
		args: []string{"src"},
	}
	w := bufWriter()
	printOpFuncHdr(w, op)
	w.Increment(1)

	// read source (always an immediate value)
	printReadImm(w, "src", sz)

	// dest could be EA, SR or SR
	if mod == 0x07 && reg == 0x04 {
		switch sz {
		default:
			err = errNotImplemented
			return

		case 0x00: // byte to CCR
			t.dst = "CCR"
			fmt.Fprintln(w, "c.SR |= (uint32(src) & 0x1F)")

		case 0x01: // word to SR
			// TODO: Is ORI to SR a supervisor only function?
			t.dst = "SR"
			fmt.Fprintln(w, "c.SR |= uint32(src) & 0x1F")
		}
	} else {
		// TODO: eliminate where source and destination are the same

		// read destination
		if err = printDestRead(w, "dst", byte(op), sz, t); err != nil {
			return
		}

		// mutate destination
		szt := SizeTypes[sz]
		mask := RegisterMasks[sz]
		switch op & 0x0E00 { // bits 5 - 7
		default:
			err = errNotImplemented
			return

		case 0x0000: // ori
			t.op = "ori"
			fmt.Fprintf(w, "v := %s(dst) | %s(src)\n", szt, szt)

		case 0x0200: // andi
			t.op = "andi"
			// we need to ensure that only the bits for the target operand size are
			// modified in register operations.
			if mod < 2 && sz < 2 { // data or address register
				fmt.Fprintf(w, "v := (dst & 0x%X) | uint32(%s(dst)&%s(src))\n", mask, szt, szt)
			} else {
				fmt.Fprintf(w, "v := %s(dst) & %s(src)\n", szt, szt)
			}

		case 0x0400: // subi
			t.op = "subi"
			fmt.Fprintf(w, "v := %s(dst) - %s(src)\n", szt, szt)

		case 0x0600: // addi
			t.op = "addi"
			fmt.Fprintf(w, "v := %s(dst) + %s(src)\n", szt, szt)

		case 0x0900: // eori
			t.op = "eori"
			fmt.Fprintf(w, "v := %s(dst) ^ %s(src)\n", szt, szt)

		}

		// write to destination
		if err = printDestWrite(w, byte(op), t); err != nil {
			return
		}
	}

	w.Decrement(1)
	printOpFuncFtr(w, t)
	return w.String(), nil
}

// genTrap implements the following operations:
// - TRAP						4-118
//
func genTrap(op uint16) (fn string, err error) {
	if op&0xFFF0 != 0x4E40 {
		err = errNotImplemented
		return
	}
	vec := (op & 0x00F)
	t := &traceMessage{
		op:     "trap",
		src:    fmt.Sprintf("#%d", vec),
		noSize: true,
	}
	vec += 32

	w := bufWriter()
	printOpFuncHdr(w, op)
	w.Increment(1)

	// TODO: traps should do something
	fmt.Fprintf(w, "if c.handlers[%d] != nil {\n", vec)
	w.Increment(1)
	fmt.Fprintf(w, "c.err = c.handlers[%d].Exception(c, %d)\n", vec, vec)
	w.Decrement(1)
	fmt.Fprintln(w, "}")

	w.Decrement(1)
	printOpFuncFtr(w, t)
	return w.String(), nil
}
